---
title: "Connecting to a FixelDB Demo"
output: html_notebook
---


```{r}
library(tidyverse)
library(RMariaDB)
library(progress)
library(tictoc)
library(furrr)
library(pool)
```


```{r}
pool <- dbPool(
  drv = RMySQL::MySQL(),
  host = "127.0.0.1",
  username = "fixeluser",
  password = "fixels",
  port = 3306,
  dbname = "fixeldb"
)

onStop(function() {
  poolClose(pool)
})

con <- DBI::dbConnect(RMySQL::MySQL(),
  host = "127.0.0.1",
  user = "fixeluser",
  password = "fixels",
  port=3306,
  dbname="fixeldb"
)
```

```{r}
voxels <- tbl(con, "voxels")
voxels
```

Well that works.

```{r}
phenotypes <- tbl(con, "phenotypes")
phenotypes
```

```{r}
res = dbGetQuery(con, "SELECT * FROM FD A INNER JOIN phenotypes B ON A._id = B._id WHERE A.fixel_id = 1;")
res
```

That works too.

```{r}
n_id <- dbGetQuery(con, "SELECT MAX(fixel_id) FROM FD;") %>%
  as.integer()


```

```{r}
results <- data.frame()

tic.clearlog()
for (x in 1:n_id){
  tic(x)
  res = dbGetQuery(con, sprintf("SELECT * FROM FD A INNER JOIN phenotypes B ON A._id = B._id WHERE A.fixel_id = %d", x))
  print(x)
  results <- with(res, t.test(value ~ Diagnosis)) %>% 
    broom::tidy() %>%
    bind_rows(results, .)
  toc(log = TRUE, quiet = TRUE)
}

results <- results %>%
  mutate(time = unlist(lapply(log.lst, function(x) x$toc - x$tic)))

tic.clearlog()
```

```{r}
assert_returns_row <- function(f){
  
  # asserts that the function the user passes will return a row
  
}
```

```{r}
myfunc <- function(id){
  
  query <- sprintf("SELECT * FROM FD A INNER JOIN phenotypes B ON A._id = B._id WHERE A.fixel_id = %d", id)
  print(query)
  
  mtcars %>%
    slice(-id) %>%
    summarise_all(c(mean)) %>%
    return()

}
```

```{r}
tic()
result <- map_dfr(1:10, myfunc)
toc()
```

```{r}
tic()
result <- future_map_dfr(1:10, myfunc)
toc()
```

```{r}
myfunc2 <- function(id){
  
  t0 <- Sys.time()
  
  tryCatch({
    res = dbGetQuery(con, sprintf("SELECT * FROM FD A INNER JOIN phenotypes B ON A._id = B._id WHERE A.fixel_id = %d", id))
    if(nrow(res) < 1){
      stop(sprintf("No rows returned in query: fixel_id = %d", id))
    }
    results <- with(res, t.test(value ~ Diagnosis)) %>% 
      broom::tidy()    
    }, 
    error=function(error_message) {
        message(error_message)
        results = data.frame(time = NA)
    }
  )
  
  t1 <- Sys.time()
  
  results %>%
    mutate(time = as.double(difftime(t1, t0, units = 'secs'))) %>%
    return()

}

plan(multiprocess)
future_map_dfr(1:n_id, myfunc2)
```

