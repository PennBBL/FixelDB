---
title: "Fixel-Based Analysis Using HDF5 Files"
output: html_notebook
---

```{r}
library(here)
library(tidyverse)
```


# Demo

TODO: Blah blah blah walkthrough

# Under the Hood

Fixel-based analysis in R is an interesting approach to studying diffusion in the brain. Just like voxel-based analysis, fixels the interactions between them may hold useful information about neuroanatomy, development, or pathology.

## Fixel Data Structure

Describe fixel data as output by mrtrix

## HDF5

R is an excellent tool for tidy data analysis. However, because of the complexity and size of fixel data, reading fixel data into memory is not an efficient strategy. Instead, we use the `HDF5Array` package to analyse data on-disk. This saves computational space in the R environment and allows for complex data to be represented in a single hierarchical file format. `HDF5Array` is an extension of the `DelayedArray` package that implements analysis on-disk data in R.

## `.mif` to `.h5`

R currently does not handle `.mif` files generated by mrtrix, but Python does. Since we only need Python for the transformation of data from `.mif` to `.h5`, we containerise a Python script that does this work for us, freeing up the R user from having to fiddle with Python environments and packages -- everything is provided in the container. The only requirement, therefore, is to have Docker installed and running.

Here is the python script that generates a `.h5` fixel database:

```{r, comment=''}
cat(readLines(here('fixeldb/fixels.py')), sep = '\n')
```

Again, the R user need not worry about any of this, since the Docker image comes ready to execute this in full.

This script is executed in the Docker container by running the following:

```{bash}
echo docker run blah
```

This is packaged in the function `create_fixelDB()`, which returns the path to the newly processed fixel data in HDF5 format:

```{r}
index_file = here('data/ZAPR01_Fixels/FD/index.mif')
directions_file = here('data/ZAPR01_Fixels/FD/directions.mif')
cohort_file = here('data/ZAPR01_Fixels/fd_inputs.csv')

# fpath <- create_fixelDB(index_file, directions_file, cohort_file)

fpath <- "data/fixels.h5"

fpath
```

## Reading in Fixel Data

You can read in the fixel data with `read_fixelDB(fpath)`

```{r}
my_fixel_data <- read_fixelDB(here('data', 'fixels.h5'), here('data', 'test_cohort.csv'))
my_fixel_data
```

We can see that although the dimensions of these datasets is large, the object itself is small:

```{r}
object.size(my_fixel_data)
```

So, in order to get a single fixel, use `get_fixel_values(data, id)`:

```{r}
my_id <- 10

get_fixel_values(my_fixel_data, my_id)
```

This shows the value for `FD` at the `r id`*th* fixel, where each row is a participant. You can group the data like so:

```{r}
n <- 1:200

purrr::map_dfr(n, function(x){
  
  get_fixel_values(my_fixel_data, x)
  
})
```

Of course, this method is not efficient as it uses `rbind` on a growing object -- (very inefficient)[https://stackoverflow.com/questions/14693956/how-can-i-prevent-rbind-from-geting-really-slow-as-dataframe-grows-larger]. Instead, pre-allocate the object:

```{r}
n <- c(10, 100, 500, 1000, 5000, 10000, 50000, 100000, 150000, 180000)

tic.clearlog()

for(nn in n){
  
  tic()
  
  purrr::map_dfr(1:nn, function(x){
  
    get_fixel_values(my_fixel_data, x)
    
  })
  
  toc(log = TRUE, quiet = TRUE)
  
}

log.txt <- tic.log(format = TRUE)

```

```{r}
n <- c(10, 100, 500, 1000, 5000, 10000, 50000, 100000, 150000, 180000)

tic.clearlog()

for(nn in n){
  
  tic()
  
  fxl_list <- vector("list", nn)
  for(x in 1:nn){
  
    fxl_list[[x]] <- get_fixel_values(my_fixel_data, x)
  }
  
  do.call(rbind, fxl_list)
  
  toc(log = TRUE, quiet = TRUE)
  
}

log.txt2 <- tic.log(format = TRUE)

```

